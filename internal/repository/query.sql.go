// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
)

const getAllFiles = `-- name: GetAllFiles :many
SELECT hash, filename, extension, size, password, uploaded_at, expires_at
FROM files
ORDER BY uploaded_at
`

func (q *Queries) GetAllFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, getAllFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.Hash,
			&i.Filename,
			&i.Extension,
			&i.Size,
			&i.Password,
			&i.UploadedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPastes = `-- name: GetAllPastes :many
SELECT hash, filename, size, language, password, uploaded_at, expires_at
FROM pastes
ORDER BY uploaded_at
`

func (q *Queries) GetAllPastes(ctx context.Context) ([]Paste, error) {
	rows, err := q.db.QueryContext(ctx, getAllPastes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Paste
	for rows.Next() {
		var i Paste
		if err := rows.Scan(
			&i.Hash,
			&i.Filename,
			&i.Size,
			&i.Language,
			&i.Password,
			&i.UploadedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTokens = `-- name: GetAllTokens :many
SELECT token, created_at
FROM tokens
ORDER BY created_at
`

func (q *Queries) GetAllTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, getAllTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(&i.Token, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileByHash = `-- name: GetFileByHash :one
SELECT hash, filename, extension, size, password, uploaded_at, expires_at
FROM files
WHERE hash = ?
  AND (expires_at < CURRENT_TIMESTAMP OR expires_at IS NULL)
LIMIT 1
`

func (q *Queries) GetFileByHash(ctx context.Context, hash string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByHash, hash)
	var i File
	err := row.Scan(
		&i.Hash,
		&i.Filename,
		&i.Extension,
		&i.Size,
		&i.Password,
		&i.UploadedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getPasteByHash = `-- name: GetPasteByHash :one
SELECT hash, filename, size, language, password, uploaded_at, expires_at
FROM pastes
WHERE hash = ?
  AND (expires_at < CURRENT_TIMESTAMP OR expires_at IS NULL)
LIMIT 1
`

func (q *Queries) GetPasteByHash(ctx context.Context, hash string) (Paste, error) {
	row := q.db.QueryRowContext(ctx, getPasteByHash, hash)
	var i Paste
	err := row.Scan(
		&i.Hash,
		&i.Filename,
		&i.Size,
		&i.Language,
		&i.Password,
		&i.UploadedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getStats = `-- name: GetStats :one
SELECT cast((SELECT count(*)
             FROM files
             WHERE (expires_at < CURRENT_TIMESTAMP OR expires_at IS NULL)) AS int) AS 'n_files',
       cast((SELECT count(*)
             FROM pastes
             WHERE (expires_at < CURRENT_TIMESTAMP OR expires_at IS NULL)) AS int) AS 'n_pastes',
       cast(sum(files.size) as int)                                                AS 'files_size',
       cast(sum(pastes.size) as int)                                               AS 'pastes_size'
FROM files,
     pastes
`

type GetStatsRow struct {
	NFiles     int64
	NPastes    int64
	FilesSize  int64
	PastesSize int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(
		&i.NFiles,
		&i.NPastes,
		&i.FilesSize,
		&i.PastesSize,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT token, created_at
FROM tokens
WHERE token = ?
`

func (q *Queries) GetToken(ctx context.Context, token string) (Token, error) {
	row := q.db.QueryRowContext(ctx, getToken, token)
	var i Token
	err := row.Scan(&i.Token, &i.CreatedAt)
	return i, err
}

const insertFile = `-- name: InsertFile :execresult
INSERT INTO files(hash, filename, extension, size, password, expires_at)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(hash) DO UPDATE SET password=excluded.password,
                                expires_at=excluded.expires_at
`

type InsertFileParams struct {
	Hash      string
	Filename  string
	Extension string
	Size      int64
	Password  sql.NullString
	ExpiresAt sql.NullTime
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertFile,
		arg.Hash,
		arg.Filename,
		arg.Extension,
		arg.Size,
		arg.Password,
		arg.ExpiresAt,
	)
}

const insertPaste = `-- name: InsertPaste :exec
INSERT INTO pastes(hash, filename, size, language, password, expires_at)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(hash) DO UPDATE SET language=excluded.language,
                                password=excluded.password,
                                expires_at=excluded.expires_at
`

type InsertPasteParams struct {
	Hash      string
	Filename  string
	Size      int64
	Language  sql.NullString
	Password  sql.NullString
	ExpiresAt sql.NullTime
}

func (q *Queries) InsertPaste(ctx context.Context, arg InsertPasteParams) error {
	_, err := q.db.ExecContext(ctx, insertPaste,
		arg.Hash,
		arg.Filename,
		arg.Size,
		arg.Language,
		arg.Password,
		arg.ExpiresAt,
	)
	return err
}

const registerToken = `-- name: RegisterToken :exec
INSERT INTO tokens(token)
VALUES (?)
ON CONFLICT DO NOTHING
`

func (q *Queries) RegisterToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, registerToken, token)
	return err
}

const unregisterAllTokens = `-- name: UnregisterAllTokens :exec
DELETE
FROM tokens
`

func (q *Queries) UnregisterAllTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, unregisterAllTokens)
	return err
}

const unregisterToken = `-- name: UnregisterToken :exec
DELETE
FROM tokens
WHERE token = ?
`

func (q *Queries) UnregisterToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, unregisterToken, token)
	return err
}
